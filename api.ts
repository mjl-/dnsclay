// NOTE: GENERATED by github.com/mjl-/sherpats, DO NOT MODIFY

namespace api {

// Zone for which DNS records are managed, for which a delegation with NS records
// exists. Commonly called "domains". Subdomains are not necessarily zones, they
// are just names with dots in a zone.
export interface Zone {
	Name: string  // Absolute name with trailing dot. In lower-case form.
	ProviderConfigName: string
	SerialLocal: Serial  // Locally known serial. Will be 0 for newly created zones. Can be different from SerialRemote since not all name servers change serials on zone changes.
	SerialRemote: Serial  // Serial as known at remote. Used during refresh to decide whether to sync. Not meaningful when <= 1 (e.g. always for AWS Route53).
	LastSync?: Date | null  // Last time an attempt to sync was made. Used for periodic sync.
	LastRecordChange?: Date | null  // Last time a change in records was detected.
	SyncInterval: number  // Time between automatic synchronizations by getting all records.
	RefreshInterval: number  // Time between zone refresh: checks for an updated SOA record (after which a sync is initiated). After a detected record change, checks are done more often. For 1 RefreshInterval, during the first 1/10th of time, a check is done 5 times. For the remaining 9/10th of time, a check is also done every 10 times.
	NextSync: Date
	NextRefresh: Date
}

export interface ProviderConfig {
	Name: string
	ProviderName: string  // Name of a libdns package.
	ProviderConfigJSON: string  // JSON encoding of the "Provider" type from the libdns package referenced by ProviderName.
}

// ZoneNotify is an address to DNS NOTIFY when a change to the zone is discovered.
export interface ZoneNotify {
	ID: number
	Created: Date
	Zone: string
	Address: string  // E.g. 127.0.0.1:53
	Protocol: string  // "tcp" or "udp"
}

// Credential is used for TSIG or mutual TLS authentication during DNS.
export interface Credential {
	ID: number
	Created: Date
	Name: string  // Without trailing dot for TSIG, we add it during DNS. rfc/8945:245
	Type: string  // "tsig" or "tlspubkey"
	TSIGSecret: string  // Base64-encoded.
	TLSPublicKey: string  // Raw-url-base64-encoded SHA-256 hash of TLS certificate subject public key info ("SPKI").
}

// Record is a DNS record that discovered through the API of the provider.
export interface Record {
	ID: number
	Zone: string  // Name of zone, lower-case.
	SerialFirst: Serial  // Serial where this record first appeared. For SOA records, this is equal to its Serial field.
	SerialDeleted: Serial  // Serial when record was removed. For future IXFR.
	First: Date
	Deleted?: Date | null
	AbsName: string  // Fully qualified, in lower-case.
	Type: Type  // eg A, etc.
	Class: Class
	TTL: TTL
	DataHex: string
	Value: string  // Human-readable.
	ProviderID: string  // From libdns.
}

// RecordNew is a new or updated record.
export interface RecordNew {
	RelName: string
	TTL: TTL
	Type: Type
	Value: string
}

// KnownProviders ensures all providers types are included in sherpadoc API documentation.
export interface KnownProviders {
	Xalidns: Provider_alidns
	Xautodns: Provider_autodns
	Xazure: Provider_azure
	Xbunny: Provider_bunny
	Xcivo: Provider_civo
	Xcloudflare: Provider_cloudflare
	Xddnss: Provider_ddnss
	Xdesec: Provider_desec
	Xdigitalocean: Provider_digitalocean
	Xdirectadmin: Provider_directadmin
	Xdnsimple: Provider_dnsimple
	Xdnsmadeeasy: Provider_dnsmadeeasy
	Xdnspod: Provider_dnspod
	Xdnsupdate: Provider_dnsupdate
	Xdreamhost: Provider_dreamhost
	Xduckdns: Provider_duckdns
	Xdynu: Provider_dynu
	Xdynv6: Provider_dynv6
	Xeasydns: Provider_easydns
	Xexoscale: Provider_exoscale
	Xgandi: Provider_gandi
	Xglesys: Provider_glesys
	Xgodaddy: Provider_godaddy
	Xgoogleclouddns: Provider_googleclouddns
	Xhe: Provider_he
	Xhetzner: Provider_hetzner
	Xhexonet: Provider_hexonet
	Xhosttech: Provider_hosttech
	Xhuaweicloud: Provider_huaweicloud
	Xinfomaniak: Provider_infomaniak
	Xinwx: Provider_inwx
	Xionos: Provider_ionos
	Xkatapult: Provider_katapult
	Xleaseweb: Provider_leaseweb
	Xlinode: Provider_linode
	Xloopia: Provider_loopia
	Xluadns: Provider_luadns
	Xmailinabox: Provider_mailinabox
	Xmetaname: Provider_metaname
	Xmythicbeasts: Provider_mythicbeasts
	Xnamecheap: Provider_namecheap
	Xnamedotcom: Provider_namedotcom
	Xnamesilo: Provider_namesilo
	Xnanelo: Provider_nanelo
	Xnetcup: Provider_netcup
	Xnetlify: Provider_netlify
	Xnfsn: Provider_nfsn
	Xnjalla: Provider_njalla
	Xovh: Provider_ovh
	Xporkbun: Provider_porkbun
	Xpowerdns: Provider_powerdns
	Xrfc2136: Provider_rfc2136
	Xroute53: Provider_route53
	Xscaleway: Provider_scaleway
	Xselectel: Provider_selectel
	Xtencentcloud: Provider_tencentcloud
	Xtimeweb: Provider_timeweb
	Xtotaluptime: Provider_totaluptime
	Xvultr: Provider_vultr
}

// Provider implements the libdns interfaces for Alicloud.
export interface Provider_alidns {
	access_key_id: string  // The API Key ID Required by Aliyun's for accessing the Aliyun's API
	access_key_secret: string  // The API Key Secret Required by Aliyun's for accessing the Aliyun's API
	region_id?: string | null  // Optional for identifing the region of the Aliyun's Service,The default is zh-hangzhou
}

// Provider facilitates DNS record manipulation with Autodns.
export interface Provider_autodns {
	username: string
	password: string
	Endpoint: string
	context: string
	primary: string
}

// Provider implements the libdns interfaces for Azure DNS
export interface Provider_azure {
	subscription_id?: string | null  // Subscription ID is the ID of the subscription in which the DNS zone is located. Required.
	resource_group_name?: string | null  // Resource Group Name is the name of the resource group in which the DNS zone is located. Required.
	tenant_id?: string | null  // (Optional) Tenant ID is the ID of the tenant of the Microsoft Entra ID in which the application is located. Required only when authenticating using a service principal with a secret. Do not set any value to authenticate using a managed identity.
	client_id?: string | null  // (Optional) Client ID is the ID of the application. Required only when authenticating using a service principal with a secret. Do not set any value to authenticate using a managed identity.
	client_secret?: string | null  // (Optional) Client Secret is the client secret of the application. Required only when authenticating using a service principal with a secret. Do not set any value to authenticate using a managed identity.
}

// Provider facilitates DNS record manipulation with Bunny.net
export interface Provider_bunny {
	access_key: string  // AccessKey is the Bunny.net API key - see https://docs.bunny.net/reference/bunnynet-api-overview
}

export interface Provider_civo {
	api_token?: string | null
}

// Provider implements the libdns interfaces for Cloudflare.
// TODO: Support pagination and retries, handle rate limits.
export interface Provider_cloudflare {
	api_token?: string | null  // API token is used for authentication. Make sure to use a scoped API **token**, NOT a global API **key**. It will need two permissions: Zone-Zone-Read and Zone-DNS-Edit, unless you are only using `GetRecords()`, in which case the second can be changed to Read.
}

// Provider facilitates DNS record manipulation with ddnss.
export interface Provider_ddnss {
	api_token: string
	username?: string | null
	password?: string | null
}

// Provider facilitates DNS record manipulation with deSEC.
export interface Provider_desec {
	token?: string | null  // Token is a token created on https://desec.io/tokens. A basic token without the permission to manage tokens is sufficient.
}

// Provider implements the libdns interfaces for DigitalOcean
export interface Provider_digitalocean {
	auth_token: string  // APIToken is the DigitalOcean API token - see https://www.digitalocean.com/docs/apis-clis/api/create-personal-access-token/
}

// Provider facilitates DNS record manipulation with DirectAdmin.
export interface Provider_directadmin {
	host?: string | null  // ServerURL should be the hostname (with port if necessary) of the DirectAdmin instance you are trying to use
	user?: string | null  // User should be the DirectAdmin username that the Login Key is created under
	login_key?: string | null  // LoginKey is used for authentication  The key will need two permissions:  `CMD_API_SHOW_DOMAINS`  `CMD_API_DNS_CONTROL`  Unless you are only using `GetRecords()`, in which case `CMD_API_DNS_CONTROL` can be omitted
	insecure_requests?: boolean | null  // InsecureRequests is an optional parameter used to ignore SSL related errors on the DirectAdmin host
	debug?: string | null  // Debug - can set this to stdout or stderr to dump debugging information about the API interaction with powerdns.  This will dump your auth token in plain text so be careful.
}

// Provider facilitates DNS record manipulation with DNSimple.
export interface Provider_dnsimple {
	api_access_token?: string | null
	account_id?: string | null
	api_url?: string | null
}

// Provider facilitates DNS record manipulation with DNSMadeEasy
export interface Provider_dnsmadeeasy {
	api_key?: string | null
	secret_key?: string | null
	api_endpoint?: BaseURL | null
}

// Provider implements the libdns interfaces for DNSPOD
export interface Provider_dnspod {
	auth_token: string  // APIToken is the DNSPOD API token - see https://www.dnspod.cn/docs/info.html#common-parameters
}

// Provider facilitates DNS record manipulation with the DNS UPDATE protocol.
export interface Provider_dnsupdate {
	addr?: string | null  // DNS server address
}

// Provider facilitates DNS record manipulation with Dreamhost.
export interface Provider_dreamhost {
	api_key?: string | null
}

// Provider implements the libdns interfaces for Duck DNS.
export interface Provider_duckdns {
	api_token?: string | null
	override_domain?: string | null
}

// Provider facilitates DNS record manipulation with dynu.
export interface Provider_dynu {
	api_token?: string | null  // config fields (with snake_case json struct tags on exported fields)
	own_domain?: string | null
}

// Provider for dynv6 HTTP REST API
export interface Provider_dynv6 {
	token?: string | null  // Token is required for authorization. You can generate one at: https://dynv6.com/keys
}

// Provider facilitates DNS record manipulation with EasyDNS.
export interface Provider_easydns {
	api_token?: string | null  // EasyDNS API Token (required)
	api_key?: string | null  // EasyDNS API Key (required)
	api_url?: string | null  // EasyDNS API URL (defaults to https://rest.easydns.net)
}

// Provider facilitates DNS record manipulation with Exoscale.
export interface Provider_exoscale {
	api_key?: string | null  // Exoscale API Key (required)
	api_secret?: string | null  // Exoscale API Secret (required)
}

// Provider implements the libdns interfaces for Gandi.
export interface Provider_gandi {
	bearer_token?: string | null
}

export interface Provider_glesys {
	project?: string | null
	api_key?: string | null
}

// Provider godaddy dns provider
export interface Provider_godaddy {
	api_token?: string | null
}

// Provider facilitates DNS record manipulation with Google Cloud DNS.
export interface Provider_googleclouddns {
	gcp_project?: string | null
	gcp_application_default?: string | null
}

// Provider facilitates DNS record manipulation with Hurricane Electric.
export interface Provider_he {
	api_key?: string | null  // Hurricane Electric DDNS key to use for authentication when modifying DNS records.
}

// Provider implements the libdns interfaces for Hetzner
export interface Provider_hetzner {
	auth_api_token: string  // AuthAPIToken is the Hetzner Auth API token - see https://dns.hetzner.com/api-docs#section/Authentication/Auth-API-Token
}

// Provider facilitates DNS record manipulation with Hexonet.
export interface Provider_hexonet {
	username: string
	password?: string | null
	debug?: string | null  // Debug - can set this to stdout or stderr to dump debugging information about the API interaction with hexonet.  This will dump your auth token in plain text so be careful.
}

// Provider facilitates DNS record manipulation with Hosttech.ch.
export interface Provider_hosttech {
	api_token?: string | null
}

// Provider facilitates DNS record manipulation with Huawei Cloud
export interface Provider_huaweicloud {
	access_key_id?: string | null  // AccessKeyId is required by the Huawei Cloud API for authentication.
	secret_access_key?: string | null  // SecretAccessKey is required by the Huawei Cloud API for authentication.
	region_id?: string | null  // RegionId is optional and defaults to "cn-south-1".
}

// Provider facilitates DNS record manipulation with infomaniak.
export interface Provider_infomaniak {
	api_token?: string | null  // infomaniak API token
}

// Provider facilitates DNS record manipulation with INWX.
export interface Provider_inwx {
	username?: string | null  // Username of your INWX account.
	password?: string | null  // Password of your INWX account.
	shared_secret?: string | null  // The shared secret is used to generate a TAN if you have activated "Mobile TAN" for your INWX account.
	endpoint_url?: string | null  // URL of the JSON-RPC API endpoint. It defaults to the production endpoint.
}

// Provider implements the libdns interfaces for IONOS
export interface Provider_ionos {
	auth_api_token: string  // AuthAPIToken is the IONOS Auth API token - see https://dns.ionos.com/api-docs#section/Authentication/Auth-API-Token
}

// Provider facilitates DNS record manipulation with Katapult.
export interface Provider_katapult {
	api_token?: string | null
}

// Provider facilitates DNS record manipulation with Leaseweb.
export interface Provider_leaseweb {
	api_token?: string | null  // Leasewebs API key. Generate one in the Leaseweb customer portal -> Administration -> API Key
}

// Provider facilitates DNS record manipulation with Linode.
export interface Provider_linode {
	api_token?: string | null  // APIToken is the Linode Personal Access Token, see https://cloud.linode.com/profile/tokens.
	api_url?: string | null  // APIURL is the Linode API hostname, i.e. "api.linode.com".
	api_version?: string | null  // APIVersion is the Linode API version, i.e. "v4".
}

// Provider facilitates DNS record manipulation with Loopia.
export interface Provider_loopia {
	username?: string | null
	password?: string | null
	customer?: string | null
}

// Provider facilitates DNS record manipulation with LuaDNS.
export interface Provider_luadns {
	email?: string | null
	api_key?: string | null
}

// Provider facilitates DNS record manipulation with Mail-In-A-Box.
export interface Provider_mailinabox {
	api_url?: string | null  // APIURL is the URL provided by the mailinabox admin interface, found on your box here: https://box.[your-domain.com]/admin#custom_dns https://box.[your-domain.com]/admin/dns/custom
	email_address?: string | null  // EmailAddress of an admin account. It's recommended that a dedicated account be created especially for managing DNS.
	password?: string | null  // Password of the admin account that corresponds to the email.
}

// Provider facilitates DNS record manipulation with Metaname
export interface Provider_metaname {
	api_key?: string | null
	account_reference?: string | null
	endpoint?: string | null
}

// Provider facilitates DNS record manipulation with Mythic Beasts.
export interface Provider_mythicbeasts {
	key_id?: string | null
	secret?: string | null
}

// Provider facilitates DNS record manipulation with namecheap.
// The libdns methods that return updated structs do not have
// their ID fields set since this information is not returned
// by the namecheap API.
export interface Provider_namecheap {
	api_key?: string | null  // APIKey is your namecheap API key. See: https://www.namecheap.com/support/api/intro/ for more details.
	user?: string | null  // User is your namecheap API user. This can be the same as your username.
	api_endpoint?: string | null  // APIEndpoint to use. If testing, you can use the "sandbox" endpoint instead of the production one.
	client_ip?: string | null  // ClientIP is the IP address of the requesting client. If this is not set, a discovery service will be used to determine the public ip of the machine. You must first whitelist your IP in the namecheap console before using the API.
}

// Provider implements the libdns interface for namedotcom
export interface Provider_namedotcom {
	api_token?: string | null
	user?: string | null
	server?: string | null  // e.g. https://api.name.com or https://api.dev.name.com
}

// Provider facilitates DNS record manipulation with Namesilo.
export interface Provider_namesilo {
	api_token?: string | null
}

// Provider facilitates DNS record manipulation with Nanelo
export interface Provider_nanelo {
	api_token?: string | null
}

// Provider facilitates DNS record manipulation with netcup.
// CustomerNumber, APIKey and APIPassword have to be filled with the respective credentials from netcup.
// The netcup API requires a session ID for all requests, so at the beginning of each method call
// a login is performed to receive the session ID and at the end the session is stopped with a logout.
// The mutex locks concurrent access on all four implemented methods to make sure there is
// no race condition in the netcup zone and record configuration.
export interface Provider_netcup {
	customer_number: string
	api_key: string
	api_password: string
}

// Provider implements the libdns interfaces for Netlify.
export interface Provider_netlify {
	personal_access_token?: string | null  // Personal Access Token is required to Authenticate yourself to Netlify's API
}

// Provider facilitates DNS record manipulation with nearlyfreespeech.net
export interface Provider_nfsn {
	login?: string | null  // NFSN Member Login.
	api_key?: string | null  // NFSN API Key. API Keys can be generated from the "Profile" tab in the NFSN member interface.
}

export interface Provider_njalla {
	api_token?: string | null
}

// Provider facilitates DNS record manipulation with OVH.
export interface Provider_ovh {
	endpoint?: string | null
	application_key?: string | null
	application_secret?: string | null
	consumer_key?: string | null
}

// Provider facilitates DNS record manipulation with Porkbun.
export interface Provider_porkbun {
	api_key?: string | null
	api_secret_key?: string | null
}

// Provider facilitates DNS record manipulation with PowerDNS.
export interface Provider_powerdns {
	server_url: string  // ServerURL is the location of the pdns server.
	server_id?: string | null  // ServerID is the id of the server.  localhost will be used if this is omitted.
	api_token?: string | null  // APIToken is the auth token.
	debug?: string | null  // Debug - can set this to stdout or stderr to dump debugging information about the API interaction with powerdns.  This will dump your auth token in plain text so be careful.
}

export interface Provider_rfc2136 {
	key_name?: string | null
	key_alg?: string | null
	key?: string | null
	server?: string | null
}

// Provider implements the libdns interfaces for Route53.
// 
// By default, the provider loads the AWS configuration from the environment.
// To override these values, set the fields in the Provider struct.
export interface Provider_route53 {
	region?: string | null  // Region is the AWS Region to use. If not set, it will use AWS_REGION environment variable.
	aws_profile?: string | null  // AWSProfile is the AWS Profile to use. If not set, it will use AWS_PROFILE environment variable.  Deprecated: Use Profile instead
	profile?: string | null  // AWSProfile is the AWS Profile to use. If not set, it will use AWS_PROFILE environment variable.
	access_key_id?: string | null  // AccessKeyId is the AWS Access Key ID to use. If not set, it will use AWS_ACCESS_KEY_ID
	secret_access_key?: string | null  // SecretAccessKey is the AWS Secret Access Key to use. If not set, it will use AWS_SECRET_ACCESS_KEY environment variable.
	token?: string | null  // Token is the AWS Session Token to use. If not set, it will use AWS_SESSION_TOKEN environment variable.  Deprecated: Use SessionToken instead.
	session_token?: string | null  // SessionToken is the AWS Session Token to use. If not set, it will use AWS_SESSION_TOKEN environment variable.
	max_retries?: number | null  // MaxRetries is the maximum number of retries to make when a request fails. If not set, it will use 5 retries.
	max_wait_dur?: number | null  // MaxWaitDur is the maximum amount of time in seconds to wait for a record to be propagated. If not set, it will 1 minute.
	wait_for_propagation?: boolean | null  // WaitForPropagation if set to true, it will wait for the record to be propagated before returning.
	hosted_zone_id?: string | null  // HostedZoneID is the ID of the hosted zone to use. If not set, it will be discovered from the zone name.  This option should contain only the ID; the "/hostedzone/" prefix will be added automatically.
}

export interface Provider_scaleway {
	secret_key?: string | null
	organization_id?: string | null
}

// Provider facilitates DNS record manipulation with <TODO: PROVIDER NAME>.
export interface Provider_selectel {
	user?: string | null
	password?: string | null
	account_id?: string | null
	project_name?: string | null
	KeystoneToken: string
}

// Provider is a libdns provider for Tencent Cloud DNS
export interface Provider_tencentcloud {
	SecretId: string  // SecretId is the secret ID for Tencent Cloud DNS
	SecretKey: string  // SecretKey is the secret key for Tencent Cloud DNS
}

export interface Provider_timeweb {
	ApiURL: string
	ApiToken: string
}

// Provider facilitates DNS record manipulation with Total Uptime.
export interface Provider_totaluptime {
	username?: string | null
	password?: string | null
}

// Provider implements the libdns interfaces for Vultr
// Adapted from libdns/digitalocean to work with the Vultr API
export interface Provider_vultr {
	api_token?: string | null  // APIToken is the Vultr API token see https://my.vultr.com/settings/#settingsapi
}

// Section represents documentation about a Sherpa API section, as returned by the "_docs" function.
export interface sherpadocSection {
	Name: string  // Name of an API section.
	Docs: string  // Explanation of the API in text or markdown.
	Functions?: (sherpadocFunction | null)[] | null  // Functions in this section.
	Sections?: (sherpadocSection | null)[] | null  // Subsections, each with their own documentation.
	Structs?: sherpadocStruct[] | null  // Structs as named types.
	Ints?: sherpadocInts[] | null  // Int enums as named types.
	Strings?: sherpadocStrings[] | null  // String enums used as named types.
	Version?: string | null  // Version if this API, only relevant for the top-level section of an API. Typically filled in by server at startup.
	SherpaVersion: number  // Version of sherpa this API implements. Currently at 0. Typically filled in by server at startup.
	SherpadocVersion?: number | null  // Version of the sherpadoc format. Currently at 1, the first defined version. Only relevant for the top-level section of an API.
}

// Function contains the documentation for a single function.
export interface sherpadocFunction {
	Name: string  // Name of the function.
	Docs: string  // Text or markdown, describing the function, its parameters, return types and possible errors.
	Params?: sherpadocArg[] | null
	Returns?: sherpadocArg[] | null
}

// Arg is the name and type of a function parameter or return value.
// 
// Production rules:
// 
// 	basictype := "bool" | "int8", "uint8" | "int16" | "uint16" | "int32" | "uint32" | "int64" | "uint64" | "int64s" | "uint64s" | "float32" | "float64" | "string" | "timestamp"
// 	array := "[]"
// 	map := "{}"
// 	identifier := [a-zA-Z][a-zA-Z0-9]*
// 	type := "nullable"? ("any" | basictype | identifier | array type | map type)
// 
// It is not possible to have inline structs in an Arg. Those must be encoded as a
// named type.
export interface sherpadocArg {
	Name: string  // Name of the argument.
	Typewords?: string[] | null  // Typewords is an array of tokens describing the type.
}

// Struct is a named compound type.
export interface sherpadocStruct {
	Name: string
	Docs: string
	Fields?: sherpadocField[] | null
}

// Field is a single field of a struct type.
// The type can reference another named type.
export interface sherpadocField {
	Name: string
	Docs: string
	Typewords?: string[] | null
}

// Ints is a type representing an enum with integers as types.
export interface sherpadocInts {
	Name: string
	Docs: string
	Values?: IntValue[] | null
}

export interface IntValue {
	Name: string
	Value: number
	Docs: string
}

// Strings is a type representing an enum with strings as values.
export interface sherpadocStrings {
	Name: string
	Docs: string
	Values?: StringValue[] | null
}

export interface StringValue {
	Name: string
	Value: string
	Docs: string
}

export type Serial = number

export type Type = number

export type Class = number

// These are not typed in the "dns" package API. We keep them typed internally and
// convert when needed to plain uints to/from package dns.
export type TTL = number

export enum BaseURL {
	Sandbox = "https://api.sandbox.dnsmadeeasy.com/V2.0/",
	Prod = "https://api.dnsmadeeasy.com/V2.0/",
}

export const structTypes: {[typename: string]: boolean} = {"Credential":true,"IntValue":true,"KnownProviders":true,"ProviderConfig":true,"Provider_alidns":true,"Provider_autodns":true,"Provider_azure":true,"Provider_bunny":true,"Provider_civo":true,"Provider_cloudflare":true,"Provider_ddnss":true,"Provider_desec":true,"Provider_digitalocean":true,"Provider_directadmin":true,"Provider_dnsimple":true,"Provider_dnsmadeeasy":true,"Provider_dnspod":true,"Provider_dnsupdate":true,"Provider_dreamhost":true,"Provider_duckdns":true,"Provider_dynu":true,"Provider_dynv6":true,"Provider_easydns":true,"Provider_exoscale":true,"Provider_gandi":true,"Provider_glesys":true,"Provider_godaddy":true,"Provider_googleclouddns":true,"Provider_he":true,"Provider_hetzner":true,"Provider_hexonet":true,"Provider_hosttech":true,"Provider_huaweicloud":true,"Provider_infomaniak":true,"Provider_inwx":true,"Provider_ionos":true,"Provider_katapult":true,"Provider_leaseweb":true,"Provider_linode":true,"Provider_loopia":true,"Provider_luadns":true,"Provider_mailinabox":true,"Provider_metaname":true,"Provider_mythicbeasts":true,"Provider_namecheap":true,"Provider_namedotcom":true,"Provider_namesilo":true,"Provider_nanelo":true,"Provider_netcup":true,"Provider_netlify":true,"Provider_nfsn":true,"Provider_njalla":true,"Provider_ovh":true,"Provider_porkbun":true,"Provider_powerdns":true,"Provider_rfc2136":true,"Provider_route53":true,"Provider_scaleway":true,"Provider_selectel":true,"Provider_tencentcloud":true,"Provider_timeweb":true,"Provider_totaluptime":true,"Provider_vultr":true,"Record":true,"RecordNew":true,"StringValue":true,"Zone":true,"ZoneNotify":true,"sherpadocArg":true,"sherpadocField":true,"sherpadocFunction":true,"sherpadocInts":true,"sherpadocSection":true,"sherpadocStrings":true,"sherpadocStruct":true}
export const stringsTypes: {[typename: string]: boolean} = {"BaseURL":true}
export const intsTypes: {[typename: string]: boolean} = {"Class":true,"Serial":true,"TTL":true,"Type":true}
export const types: TypenameMap = {
	"Zone": {"Name":"Zone","Docs":"","Fields":[{"Name":"Name","Docs":"","Typewords":["string"]},{"Name":"ProviderConfigName","Docs":"","Typewords":["string"]},{"Name":"SerialLocal","Docs":"","Typewords":["Serial"]},{"Name":"SerialRemote","Docs":"","Typewords":["Serial"]},{"Name":"LastSync","Docs":"","Typewords":["nullable","timestamp"]},{"Name":"LastRecordChange","Docs":"","Typewords":["nullable","timestamp"]},{"Name":"SyncInterval","Docs":"","Typewords":["int64"]},{"Name":"RefreshInterval","Docs":"","Typewords":["int64"]},{"Name":"NextSync","Docs":"","Typewords":["timestamp"]},{"Name":"NextRefresh","Docs":"","Typewords":["timestamp"]}]},
	"ProviderConfig": {"Name":"ProviderConfig","Docs":"","Fields":[{"Name":"Name","Docs":"","Typewords":["string"]},{"Name":"ProviderName","Docs":"","Typewords":["string"]},{"Name":"ProviderConfigJSON","Docs":"","Typewords":["string"]}]},
	"ZoneNotify": {"Name":"ZoneNotify","Docs":"","Fields":[{"Name":"ID","Docs":"","Typewords":["int64"]},{"Name":"Created","Docs":"","Typewords":["timestamp"]},{"Name":"Zone","Docs":"","Typewords":["string"]},{"Name":"Address","Docs":"","Typewords":["string"]},{"Name":"Protocol","Docs":"","Typewords":["string"]}]},
	"Credential": {"Name":"Credential","Docs":"","Fields":[{"Name":"ID","Docs":"","Typewords":["int64"]},{"Name":"Created","Docs":"","Typewords":["timestamp"]},{"Name":"Name","Docs":"","Typewords":["string"]},{"Name":"Type","Docs":"","Typewords":["string"]},{"Name":"TSIGSecret","Docs":"","Typewords":["string"]},{"Name":"TLSPublicKey","Docs":"","Typewords":["string"]}]},
	"Record": {"Name":"Record","Docs":"","Fields":[{"Name":"ID","Docs":"","Typewords":["int64"]},{"Name":"Zone","Docs":"","Typewords":["string"]},{"Name":"SerialFirst","Docs":"","Typewords":["Serial"]},{"Name":"SerialDeleted","Docs":"","Typewords":["Serial"]},{"Name":"First","Docs":"","Typewords":["timestamp"]},{"Name":"Deleted","Docs":"","Typewords":["nullable","timestamp"]},{"Name":"AbsName","Docs":"","Typewords":["string"]},{"Name":"Type","Docs":"","Typewords":["Type"]},{"Name":"Class","Docs":"","Typewords":["Class"]},{"Name":"TTL","Docs":"","Typewords":["TTL"]},{"Name":"DataHex","Docs":"","Typewords":["string"]},{"Name":"Value","Docs":"","Typewords":["string"]},{"Name":"ProviderID","Docs":"","Typewords":["string"]}]},
	"RecordNew": {"Name":"RecordNew","Docs":"","Fields":[{"Name":"RelName","Docs":"","Typewords":["string"]},{"Name":"TTL","Docs":"","Typewords":["TTL"]},{"Name":"Type","Docs":"","Typewords":["Type"]},{"Name":"Value","Docs":"","Typewords":["string"]}]},
	"KnownProviders": {"Name":"KnownProviders","Docs":"","Fields":[{"Name":"Xalidns","Docs":"","Typewords":["Provider_alidns"]},{"Name":"Xautodns","Docs":"","Typewords":["Provider_autodns"]},{"Name":"Xazure","Docs":"","Typewords":["Provider_azure"]},{"Name":"Xbunny","Docs":"","Typewords":["Provider_bunny"]},{"Name":"Xcivo","Docs":"","Typewords":["Provider_civo"]},{"Name":"Xcloudflare","Docs":"","Typewords":["Provider_cloudflare"]},{"Name":"Xddnss","Docs":"","Typewords":["Provider_ddnss"]},{"Name":"Xdesec","Docs":"","Typewords":["Provider_desec"]},{"Name":"Xdigitalocean","Docs":"","Typewords":["Provider_digitalocean"]},{"Name":"Xdirectadmin","Docs":"","Typewords":["Provider_directadmin"]},{"Name":"Xdnsimple","Docs":"","Typewords":["Provider_dnsimple"]},{"Name":"Xdnsmadeeasy","Docs":"","Typewords":["Provider_dnsmadeeasy"]},{"Name":"Xdnspod","Docs":"","Typewords":["Provider_dnspod"]},{"Name":"Xdnsupdate","Docs":"","Typewords":["Provider_dnsupdate"]},{"Name":"Xdreamhost","Docs":"","Typewords":["Provider_dreamhost"]},{"Name":"Xduckdns","Docs":"","Typewords":["Provider_duckdns"]},{"Name":"Xdynu","Docs":"","Typewords":["Provider_dynu"]},{"Name":"Xdynv6","Docs":"","Typewords":["Provider_dynv6"]},{"Name":"Xeasydns","Docs":"","Typewords":["Provider_easydns"]},{"Name":"Xexoscale","Docs":"","Typewords":["Provider_exoscale"]},{"Name":"Xgandi","Docs":"","Typewords":["Provider_gandi"]},{"Name":"Xglesys","Docs":"","Typewords":["Provider_glesys"]},{"Name":"Xgodaddy","Docs":"","Typewords":["Provider_godaddy"]},{"Name":"Xgoogleclouddns","Docs":"","Typewords":["Provider_googleclouddns"]},{"Name":"Xhe","Docs":"","Typewords":["Provider_he"]},{"Name":"Xhetzner","Docs":"","Typewords":["Provider_hetzner"]},{"Name":"Xhexonet","Docs":"","Typewords":["Provider_hexonet"]},{"Name":"Xhosttech","Docs":"","Typewords":["Provider_hosttech"]},{"Name":"Xhuaweicloud","Docs":"","Typewords":["Provider_huaweicloud"]},{"Name":"Xinfomaniak","Docs":"","Typewords":["Provider_infomaniak"]},{"Name":"Xinwx","Docs":"","Typewords":["Provider_inwx"]},{"Name":"Xionos","Docs":"","Typewords":["Provider_ionos"]},{"Name":"Xkatapult","Docs":"","Typewords":["Provider_katapult"]},{"Name":"Xleaseweb","Docs":"","Typewords":["Provider_leaseweb"]},{"Name":"Xlinode","Docs":"","Typewords":["Provider_linode"]},{"Name":"Xloopia","Docs":"","Typewords":["Provider_loopia"]},{"Name":"Xluadns","Docs":"","Typewords":["Provider_luadns"]},{"Name":"Xmailinabox","Docs":"","Typewords":["Provider_mailinabox"]},{"Name":"Xmetaname","Docs":"","Typewords":["Provider_metaname"]},{"Name":"Xmythicbeasts","Docs":"","Typewords":["Provider_mythicbeasts"]},{"Name":"Xnamecheap","Docs":"","Typewords":["Provider_namecheap"]},{"Name":"Xnamedotcom","Docs":"","Typewords":["Provider_namedotcom"]},{"Name":"Xnamesilo","Docs":"","Typewords":["Provider_namesilo"]},{"Name":"Xnanelo","Docs":"","Typewords":["Provider_nanelo"]},{"Name":"Xnetcup","Docs":"","Typewords":["Provider_netcup"]},{"Name":"Xnetlify","Docs":"","Typewords":["Provider_netlify"]},{"Name":"Xnfsn","Docs":"","Typewords":["Provider_nfsn"]},{"Name":"Xnjalla","Docs":"","Typewords":["Provider_njalla"]},{"Name":"Xovh","Docs":"","Typewords":["Provider_ovh"]},{"Name":"Xporkbun","Docs":"","Typewords":["Provider_porkbun"]},{"Name":"Xpowerdns","Docs":"","Typewords":["Provider_powerdns"]},{"Name":"Xrfc2136","Docs":"","Typewords":["Provider_rfc2136"]},{"Name":"Xroute53","Docs":"","Typewords":["Provider_route53"]},{"Name":"Xscaleway","Docs":"","Typewords":["Provider_scaleway"]},{"Name":"Xselectel","Docs":"","Typewords":["Provider_selectel"]},{"Name":"Xtencentcloud","Docs":"","Typewords":["Provider_tencentcloud"]},{"Name":"Xtimeweb","Docs":"","Typewords":["Provider_timeweb"]},{"Name":"Xtotaluptime","Docs":"","Typewords":["Provider_totaluptime"]},{"Name":"Xvultr","Docs":"","Typewords":["Provider_vultr"]}]},
	"Provider_alidns": {"Name":"Provider_alidns","Docs":"","Fields":[{"Name":"access_key_id","Docs":"","Typewords":["string"]},{"Name":"access_key_secret","Docs":"","Typewords":["string"]},{"Name":"region_id","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_autodns": {"Name":"Provider_autodns","Docs":"","Fields":[{"Name":"username","Docs":"","Typewords":["string"]},{"Name":"password","Docs":"","Typewords":["string"]},{"Name":"Endpoint","Docs":"","Typewords":["string"]},{"Name":"context","Docs":"","Typewords":["string"]},{"Name":"primary","Docs":"","Typewords":["string"]}]},
	"Provider_azure": {"Name":"Provider_azure","Docs":"","Fields":[{"Name":"subscription_id","Docs":"","Typewords":["nullable","string"]},{"Name":"resource_group_name","Docs":"","Typewords":["nullable","string"]},{"Name":"tenant_id","Docs":"","Typewords":["nullable","string"]},{"Name":"client_id","Docs":"","Typewords":["nullable","string"]},{"Name":"client_secret","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_bunny": {"Name":"Provider_bunny","Docs":"","Fields":[{"Name":"access_key","Docs":"","Typewords":["string"]}]},
	"Provider_civo": {"Name":"Provider_civo","Docs":"","Fields":[{"Name":"api_token","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_cloudflare": {"Name":"Provider_cloudflare","Docs":"","Fields":[{"Name":"api_token","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_ddnss": {"Name":"Provider_ddnss","Docs":"","Fields":[{"Name":"api_token","Docs":"","Typewords":["string"]},{"Name":"username","Docs":"","Typewords":["nullable","string"]},{"Name":"password","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_desec": {"Name":"Provider_desec","Docs":"","Fields":[{"Name":"token","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_digitalocean": {"Name":"Provider_digitalocean","Docs":"","Fields":[{"Name":"auth_token","Docs":"","Typewords":["string"]}]},
	"Provider_directadmin": {"Name":"Provider_directadmin","Docs":"","Fields":[{"Name":"host","Docs":"","Typewords":["nullable","string"]},{"Name":"user","Docs":"","Typewords":["nullable","string"]},{"Name":"login_key","Docs":"","Typewords":["nullable","string"]},{"Name":"insecure_requests","Docs":"","Typewords":["nullable","bool"]},{"Name":"debug","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_dnsimple": {"Name":"Provider_dnsimple","Docs":"","Fields":[{"Name":"api_access_token","Docs":"","Typewords":["nullable","string"]},{"Name":"account_id","Docs":"","Typewords":["nullable","string"]},{"Name":"api_url","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_dnsmadeeasy": {"Name":"Provider_dnsmadeeasy","Docs":"","Fields":[{"Name":"api_key","Docs":"","Typewords":["nullable","string"]},{"Name":"secret_key","Docs":"","Typewords":["nullable","string"]},{"Name":"api_endpoint","Docs":"","Typewords":["nullable","BaseURL"]}]},
	"Provider_dnspod": {"Name":"Provider_dnspod","Docs":"","Fields":[{"Name":"auth_token","Docs":"","Typewords":["string"]}]},
	"Provider_dnsupdate": {"Name":"Provider_dnsupdate","Docs":"","Fields":[{"Name":"addr","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_dreamhost": {"Name":"Provider_dreamhost","Docs":"","Fields":[{"Name":"api_key","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_duckdns": {"Name":"Provider_duckdns","Docs":"","Fields":[{"Name":"api_token","Docs":"","Typewords":["nullable","string"]},{"Name":"override_domain","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_dynu": {"Name":"Provider_dynu","Docs":"","Fields":[{"Name":"api_token","Docs":"","Typewords":["nullable","string"]},{"Name":"own_domain","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_dynv6": {"Name":"Provider_dynv6","Docs":"","Fields":[{"Name":"token","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_easydns": {"Name":"Provider_easydns","Docs":"","Fields":[{"Name":"api_token","Docs":"","Typewords":["nullable","string"]},{"Name":"api_key","Docs":"","Typewords":["nullable","string"]},{"Name":"api_url","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_exoscale": {"Name":"Provider_exoscale","Docs":"","Fields":[{"Name":"api_key","Docs":"","Typewords":["nullable","string"]},{"Name":"api_secret","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_gandi": {"Name":"Provider_gandi","Docs":"","Fields":[{"Name":"bearer_token","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_glesys": {"Name":"Provider_glesys","Docs":"","Fields":[{"Name":"project","Docs":"","Typewords":["nullable","string"]},{"Name":"api_key","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_godaddy": {"Name":"Provider_godaddy","Docs":"","Fields":[{"Name":"api_token","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_googleclouddns": {"Name":"Provider_googleclouddns","Docs":"","Fields":[{"Name":"gcp_project","Docs":"","Typewords":["nullable","string"]},{"Name":"gcp_application_default","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_he": {"Name":"Provider_he","Docs":"","Fields":[{"Name":"api_key","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_hetzner": {"Name":"Provider_hetzner","Docs":"","Fields":[{"Name":"auth_api_token","Docs":"","Typewords":["string"]}]},
	"Provider_hexonet": {"Name":"Provider_hexonet","Docs":"","Fields":[{"Name":"username","Docs":"","Typewords":["string"]},{"Name":"password","Docs":"","Typewords":["nullable","string"]},{"Name":"debug","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_hosttech": {"Name":"Provider_hosttech","Docs":"","Fields":[{"Name":"api_token","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_huaweicloud": {"Name":"Provider_huaweicloud","Docs":"","Fields":[{"Name":"access_key_id","Docs":"","Typewords":["nullable","string"]},{"Name":"secret_access_key","Docs":"","Typewords":["nullable","string"]},{"Name":"region_id","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_infomaniak": {"Name":"Provider_infomaniak","Docs":"","Fields":[{"Name":"api_token","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_inwx": {"Name":"Provider_inwx","Docs":"","Fields":[{"Name":"username","Docs":"","Typewords":["nullable","string"]},{"Name":"password","Docs":"","Typewords":["nullable","string"]},{"Name":"shared_secret","Docs":"","Typewords":["nullable","string"]},{"Name":"endpoint_url","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_ionos": {"Name":"Provider_ionos","Docs":"","Fields":[{"Name":"auth_api_token","Docs":"","Typewords":["string"]}]},
	"Provider_katapult": {"Name":"Provider_katapult","Docs":"","Fields":[{"Name":"api_token","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_leaseweb": {"Name":"Provider_leaseweb","Docs":"","Fields":[{"Name":"api_token","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_linode": {"Name":"Provider_linode","Docs":"","Fields":[{"Name":"api_token","Docs":"","Typewords":["nullable","string"]},{"Name":"api_url","Docs":"","Typewords":["nullable","string"]},{"Name":"api_version","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_loopia": {"Name":"Provider_loopia","Docs":"","Fields":[{"Name":"username","Docs":"","Typewords":["nullable","string"]},{"Name":"password","Docs":"","Typewords":["nullable","string"]},{"Name":"customer","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_luadns": {"Name":"Provider_luadns","Docs":"","Fields":[{"Name":"email","Docs":"","Typewords":["nullable","string"]},{"Name":"api_key","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_mailinabox": {"Name":"Provider_mailinabox","Docs":"","Fields":[{"Name":"api_url","Docs":"","Typewords":["nullable","string"]},{"Name":"email_address","Docs":"","Typewords":["nullable","string"]},{"Name":"password","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_metaname": {"Name":"Provider_metaname","Docs":"","Fields":[{"Name":"api_key","Docs":"","Typewords":["nullable","string"]},{"Name":"account_reference","Docs":"","Typewords":["nullable","string"]},{"Name":"endpoint","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_mythicbeasts": {"Name":"Provider_mythicbeasts","Docs":"","Fields":[{"Name":"key_id","Docs":"","Typewords":["nullable","string"]},{"Name":"secret","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_namecheap": {"Name":"Provider_namecheap","Docs":"","Fields":[{"Name":"api_key","Docs":"","Typewords":["nullable","string"]},{"Name":"user","Docs":"","Typewords":["nullable","string"]},{"Name":"api_endpoint","Docs":"","Typewords":["nullable","string"]},{"Name":"client_ip","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_namedotcom": {"Name":"Provider_namedotcom","Docs":"","Fields":[{"Name":"api_token","Docs":"","Typewords":["nullable","string"]},{"Name":"user","Docs":"","Typewords":["nullable","string"]},{"Name":"server","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_namesilo": {"Name":"Provider_namesilo","Docs":"","Fields":[{"Name":"api_token","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_nanelo": {"Name":"Provider_nanelo","Docs":"","Fields":[{"Name":"api_token","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_netcup": {"Name":"Provider_netcup","Docs":"","Fields":[{"Name":"customer_number","Docs":"","Typewords":["string"]},{"Name":"api_key","Docs":"","Typewords":["string"]},{"Name":"api_password","Docs":"","Typewords":["string"]}]},
	"Provider_netlify": {"Name":"Provider_netlify","Docs":"","Fields":[{"Name":"personal_access_token","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_nfsn": {"Name":"Provider_nfsn","Docs":"","Fields":[{"Name":"login","Docs":"","Typewords":["nullable","string"]},{"Name":"api_key","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_njalla": {"Name":"Provider_njalla","Docs":"","Fields":[{"Name":"api_token","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_ovh": {"Name":"Provider_ovh","Docs":"","Fields":[{"Name":"endpoint","Docs":"","Typewords":["nullable","string"]},{"Name":"application_key","Docs":"","Typewords":["nullable","string"]},{"Name":"application_secret","Docs":"","Typewords":["nullable","string"]},{"Name":"consumer_key","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_porkbun": {"Name":"Provider_porkbun","Docs":"","Fields":[{"Name":"api_key","Docs":"","Typewords":["nullable","string"]},{"Name":"api_secret_key","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_powerdns": {"Name":"Provider_powerdns","Docs":"","Fields":[{"Name":"server_url","Docs":"","Typewords":["string"]},{"Name":"server_id","Docs":"","Typewords":["nullable","string"]},{"Name":"api_token","Docs":"","Typewords":["nullable","string"]},{"Name":"debug","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_rfc2136": {"Name":"Provider_rfc2136","Docs":"","Fields":[{"Name":"key_name","Docs":"","Typewords":["nullable","string"]},{"Name":"key_alg","Docs":"","Typewords":["nullable","string"]},{"Name":"key","Docs":"","Typewords":["nullable","string"]},{"Name":"server","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_route53": {"Name":"Provider_route53","Docs":"","Fields":[{"Name":"region","Docs":"","Typewords":["nullable","string"]},{"Name":"aws_profile","Docs":"","Typewords":["nullable","string"]},{"Name":"profile","Docs":"","Typewords":["nullable","string"]},{"Name":"access_key_id","Docs":"","Typewords":["nullable","string"]},{"Name":"secret_access_key","Docs":"","Typewords":["nullable","string"]},{"Name":"token","Docs":"","Typewords":["nullable","string"]},{"Name":"session_token","Docs":"","Typewords":["nullable","string"]},{"Name":"max_retries","Docs":"","Typewords":["nullable","int32"]},{"Name":"max_wait_dur","Docs":"","Typewords":["nullable","int64"]},{"Name":"wait_for_propagation","Docs":"","Typewords":["nullable","bool"]},{"Name":"hosted_zone_id","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_scaleway": {"Name":"Provider_scaleway","Docs":"","Fields":[{"Name":"secret_key","Docs":"","Typewords":["nullable","string"]},{"Name":"organization_id","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_selectel": {"Name":"Provider_selectel","Docs":"","Fields":[{"Name":"user","Docs":"","Typewords":["nullable","string"]},{"Name":"password","Docs":"","Typewords":["nullable","string"]},{"Name":"account_id","Docs":"","Typewords":["nullable","string"]},{"Name":"project_name","Docs":"","Typewords":["nullable","string"]},{"Name":"KeystoneToken","Docs":"","Typewords":["string"]}]},
	"Provider_tencentcloud": {"Name":"Provider_tencentcloud","Docs":"","Fields":[{"Name":"SecretId","Docs":"","Typewords":["string"]},{"Name":"SecretKey","Docs":"","Typewords":["string"]}]},
	"Provider_timeweb": {"Name":"Provider_timeweb","Docs":"","Fields":[{"Name":"ApiURL","Docs":"","Typewords":["string"]},{"Name":"ApiToken","Docs":"","Typewords":["string"]}]},
	"Provider_totaluptime": {"Name":"Provider_totaluptime","Docs":"","Fields":[{"Name":"username","Docs":"","Typewords":["nullable","string"]},{"Name":"password","Docs":"","Typewords":["nullable","string"]}]},
	"Provider_vultr": {"Name":"Provider_vultr","Docs":"","Fields":[{"Name":"api_token","Docs":"","Typewords":["nullable","string"]}]},
	"sherpadocSection": {"Name":"sherpadocSection","Docs":"","Fields":[{"Name":"Name","Docs":"","Typewords":["string"]},{"Name":"Docs","Docs":"","Typewords":["string"]},{"Name":"Functions","Docs":"","Typewords":["[]","nullable","sherpadocFunction"]},{"Name":"Sections","Docs":"","Typewords":["[]","nullable","sherpadocSection"]},{"Name":"Structs","Docs":"","Typewords":["[]","sherpadocStruct"]},{"Name":"Ints","Docs":"","Typewords":["[]","sherpadocInts"]},{"Name":"Strings","Docs":"","Typewords":["[]","sherpadocStrings"]},{"Name":"Version","Docs":"","Typewords":["nullable","string"]},{"Name":"SherpaVersion","Docs":"","Typewords":["int32"]},{"Name":"SherpadocVersion","Docs":"","Typewords":["nullable","int32"]}]},
	"sherpadocFunction": {"Name":"sherpadocFunction","Docs":"","Fields":[{"Name":"Name","Docs":"","Typewords":["string"]},{"Name":"Docs","Docs":"","Typewords":["string"]},{"Name":"Params","Docs":"","Typewords":["[]","sherpadocArg"]},{"Name":"Returns","Docs":"","Typewords":["[]","sherpadocArg"]}]},
	"sherpadocArg": {"Name":"sherpadocArg","Docs":"","Fields":[{"Name":"Name","Docs":"","Typewords":["string"]},{"Name":"Typewords","Docs":"","Typewords":["[]","string"]}]},
	"sherpadocStruct": {"Name":"sherpadocStruct","Docs":"","Fields":[{"Name":"Name","Docs":"","Typewords":["string"]},{"Name":"Docs","Docs":"","Typewords":["string"]},{"Name":"Fields","Docs":"","Typewords":["[]","sherpadocField"]}]},
	"sherpadocField": {"Name":"sherpadocField","Docs":"","Fields":[{"Name":"Name","Docs":"","Typewords":["string"]},{"Name":"Docs","Docs":"","Typewords":["string"]},{"Name":"Typewords","Docs":"","Typewords":["[]","string"]}]},
	"sherpadocInts": {"Name":"sherpadocInts","Docs":"","Fields":[{"Name":"Name","Docs":"","Typewords":["string"]},{"Name":"Docs","Docs":"","Typewords":["string"]},{"Name":"Values","Docs":"","Typewords":["[]","IntValue"]}]},
	"IntValue": {"Name":"IntValue","Docs":"","Fields":[{"Name":"Name","Docs":"","Typewords":["string"]},{"Name":"Value","Docs":"","Typewords":["int64"]},{"Name":"Docs","Docs":"","Typewords":["string"]}]},
	"sherpadocStrings": {"Name":"sherpadocStrings","Docs":"","Fields":[{"Name":"Name","Docs":"","Typewords":["string"]},{"Name":"Docs","Docs":"","Typewords":["string"]},{"Name":"Values","Docs":"","Typewords":["[]","StringValue"]}]},
	"StringValue": {"Name":"StringValue","Docs":"","Fields":[{"Name":"Name","Docs":"","Typewords":["string"]},{"Name":"Value","Docs":"","Typewords":["string"]},{"Name":"Docs","Docs":"","Typewords":["string"]}]},
	"Serial": {"Name":"Serial","Docs":"","Values":null},
	"Type": {"Name":"Type","Docs":"","Values":null},
	"Class": {"Name":"Class","Docs":"","Values":null},
	"TTL": {"Name":"TTL","Docs":"","Values":null},
	"BaseURL": {"Name":"BaseURL","Docs":"","Values":[{"Name":"Sandbox","Value":"https://api.sandbox.dnsmadeeasy.com/V2.0/","Docs":""},{"Name":"Prod","Value":"https://api.dnsmadeeasy.com/V2.0/","Docs":""}]},
}

export const parser = {
	Zone: (v: any) => parse("Zone", v) as Zone,
	ProviderConfig: (v: any) => parse("ProviderConfig", v) as ProviderConfig,
	ZoneNotify: (v: any) => parse("ZoneNotify", v) as ZoneNotify,
	Credential: (v: any) => parse("Credential", v) as Credential,
	Record: (v: any) => parse("Record", v) as Record,
	RecordNew: (v: any) => parse("RecordNew", v) as RecordNew,
	KnownProviders: (v: any) => parse("KnownProviders", v) as KnownProviders,
	Provider_alidns: (v: any) => parse("Provider_alidns", v) as Provider_alidns,
	Provider_autodns: (v: any) => parse("Provider_autodns", v) as Provider_autodns,
	Provider_azure: (v: any) => parse("Provider_azure", v) as Provider_azure,
	Provider_bunny: (v: any) => parse("Provider_bunny", v) as Provider_bunny,
	Provider_civo: (v: any) => parse("Provider_civo", v) as Provider_civo,
	Provider_cloudflare: (v: any) => parse("Provider_cloudflare", v) as Provider_cloudflare,
	Provider_ddnss: (v: any) => parse("Provider_ddnss", v) as Provider_ddnss,
	Provider_desec: (v: any) => parse("Provider_desec", v) as Provider_desec,
	Provider_digitalocean: (v: any) => parse("Provider_digitalocean", v) as Provider_digitalocean,
	Provider_directadmin: (v: any) => parse("Provider_directadmin", v) as Provider_directadmin,
	Provider_dnsimple: (v: any) => parse("Provider_dnsimple", v) as Provider_dnsimple,
	Provider_dnsmadeeasy: (v: any) => parse("Provider_dnsmadeeasy", v) as Provider_dnsmadeeasy,
	Provider_dnspod: (v: any) => parse("Provider_dnspod", v) as Provider_dnspod,
	Provider_dnsupdate: (v: any) => parse("Provider_dnsupdate", v) as Provider_dnsupdate,
	Provider_dreamhost: (v: any) => parse("Provider_dreamhost", v) as Provider_dreamhost,
	Provider_duckdns: (v: any) => parse("Provider_duckdns", v) as Provider_duckdns,
	Provider_dynu: (v: any) => parse("Provider_dynu", v) as Provider_dynu,
	Provider_dynv6: (v: any) => parse("Provider_dynv6", v) as Provider_dynv6,
	Provider_easydns: (v: any) => parse("Provider_easydns", v) as Provider_easydns,
	Provider_exoscale: (v: any) => parse("Provider_exoscale", v) as Provider_exoscale,
	Provider_gandi: (v: any) => parse("Provider_gandi", v) as Provider_gandi,
	Provider_glesys: (v: any) => parse("Provider_glesys", v) as Provider_glesys,
	Provider_godaddy: (v: any) => parse("Provider_godaddy", v) as Provider_godaddy,
	Provider_googleclouddns: (v: any) => parse("Provider_googleclouddns", v) as Provider_googleclouddns,
	Provider_he: (v: any) => parse("Provider_he", v) as Provider_he,
	Provider_hetzner: (v: any) => parse("Provider_hetzner", v) as Provider_hetzner,
	Provider_hexonet: (v: any) => parse("Provider_hexonet", v) as Provider_hexonet,
	Provider_hosttech: (v: any) => parse("Provider_hosttech", v) as Provider_hosttech,
	Provider_huaweicloud: (v: any) => parse("Provider_huaweicloud", v) as Provider_huaweicloud,
	Provider_infomaniak: (v: any) => parse("Provider_infomaniak", v) as Provider_infomaniak,
	Provider_inwx: (v: any) => parse("Provider_inwx", v) as Provider_inwx,
	Provider_ionos: (v: any) => parse("Provider_ionos", v) as Provider_ionos,
	Provider_katapult: (v: any) => parse("Provider_katapult", v) as Provider_katapult,
	Provider_leaseweb: (v: any) => parse("Provider_leaseweb", v) as Provider_leaseweb,
	Provider_linode: (v: any) => parse("Provider_linode", v) as Provider_linode,
	Provider_loopia: (v: any) => parse("Provider_loopia", v) as Provider_loopia,
	Provider_luadns: (v: any) => parse("Provider_luadns", v) as Provider_luadns,
	Provider_mailinabox: (v: any) => parse("Provider_mailinabox", v) as Provider_mailinabox,
	Provider_metaname: (v: any) => parse("Provider_metaname", v) as Provider_metaname,
	Provider_mythicbeasts: (v: any) => parse("Provider_mythicbeasts", v) as Provider_mythicbeasts,
	Provider_namecheap: (v: any) => parse("Provider_namecheap", v) as Provider_namecheap,
	Provider_namedotcom: (v: any) => parse("Provider_namedotcom", v) as Provider_namedotcom,
	Provider_namesilo: (v: any) => parse("Provider_namesilo", v) as Provider_namesilo,
	Provider_nanelo: (v: any) => parse("Provider_nanelo", v) as Provider_nanelo,
	Provider_netcup: (v: any) => parse("Provider_netcup", v) as Provider_netcup,
	Provider_netlify: (v: any) => parse("Provider_netlify", v) as Provider_netlify,
	Provider_nfsn: (v: any) => parse("Provider_nfsn", v) as Provider_nfsn,
	Provider_njalla: (v: any) => parse("Provider_njalla", v) as Provider_njalla,
	Provider_ovh: (v: any) => parse("Provider_ovh", v) as Provider_ovh,
	Provider_porkbun: (v: any) => parse("Provider_porkbun", v) as Provider_porkbun,
	Provider_powerdns: (v: any) => parse("Provider_powerdns", v) as Provider_powerdns,
	Provider_rfc2136: (v: any) => parse("Provider_rfc2136", v) as Provider_rfc2136,
	Provider_route53: (v: any) => parse("Provider_route53", v) as Provider_route53,
	Provider_scaleway: (v: any) => parse("Provider_scaleway", v) as Provider_scaleway,
	Provider_selectel: (v: any) => parse("Provider_selectel", v) as Provider_selectel,
	Provider_tencentcloud: (v: any) => parse("Provider_tencentcloud", v) as Provider_tencentcloud,
	Provider_timeweb: (v: any) => parse("Provider_timeweb", v) as Provider_timeweb,
	Provider_totaluptime: (v: any) => parse("Provider_totaluptime", v) as Provider_totaluptime,
	Provider_vultr: (v: any) => parse("Provider_vultr", v) as Provider_vultr,
	sherpadocSection: (v: any) => parse("sherpadocSection", v) as sherpadocSection,
	sherpadocFunction: (v: any) => parse("sherpadocFunction", v) as sherpadocFunction,
	sherpadocArg: (v: any) => parse("sherpadocArg", v) as sherpadocArg,
	sherpadocStruct: (v: any) => parse("sherpadocStruct", v) as sherpadocStruct,
	sherpadocField: (v: any) => parse("sherpadocField", v) as sherpadocField,
	sherpadocInts: (v: any) => parse("sherpadocInts", v) as sherpadocInts,
	IntValue: (v: any) => parse("IntValue", v) as IntValue,
	sherpadocStrings: (v: any) => parse("sherpadocStrings", v) as sherpadocStrings,
	StringValue: (v: any) => parse("StringValue", v) as StringValue,
	Serial: (v: any) => parse("Serial", v) as Serial,
	Type: (v: any) => parse("Type", v) as Type,
	Class: (v: any) => parse("Class", v) as Class,
	TTL: (v: any) => parse("TTL", v) as TTL,
	BaseURL: (v: any) => parse("BaseURL", v) as BaseURL,
}

// API is the webapi used by the admin frontend.
let defaultOptions: ClientOptions = {slicesNullable: true, mapsNullable: true, nullableOptional: true}

export class Client {
	private baseURL: string
	public authState: AuthState
	public options: ClientOptions

	constructor() {
		this.authState = {}
		this.options = {...defaultOptions}
		this.baseURL = this.options.baseURL || defaultBaseURL
	}

	withAuthToken(token: string): Client {
		const c = new Client()
		c.authState.token = token
		c.options = this.options
		return c
	}

	withOptions(options: ClientOptions): Client {
		const c = new Client()
		c.authState = this.authState
		c.options = { ...this.options, ...options }
		return c
	}

	// Zones returns all zones.
	async Zones(): Promise<Zone[] | null> {
		const fn: string = "Zones"
		const paramTypes: string[][] = []
		const returnTypes: string[][] = [["[]","Zone"]]
		const params: any[] = []
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as Zone[] | null
	}

	// Zone returns details about a single zone, including all records (including deleted), credentials, and dns notify destinations.
	async Zone(zone: string): Promise<[Zone, ProviderConfig, ZoneNotify[] | null, Credential[] | null, Record[] | null]> {
		const fn: string = "Zone"
		const paramTypes: string[][] = [["string"]]
		const returnTypes: string[][] = [["Zone"],["ProviderConfig"],["[]","ZoneNotify"],["[]","Credential"],["[]","Record"]]
		const params: any[] = [zone]
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as [Zone, ProviderConfig, ZoneNotify[] | null, Credential[] | null, Record[] | null]
	}

	// ZoneRefresh starts a sync of the records from the provider into the local
	// database, sending dns notify if needed. ZoneRefresh returns all records
	// (included deleted) from after the synchronization.
	async ZoneRefresh(zone: string): Promise<[Zone, Record[] | null]> {
		const fn: string = "ZoneRefresh"
		const paramTypes: string[][] = [["string"]]
		const returnTypes: string[][] = [["Zone"],["[]","Record"]]
		const params: any[] = [zone]
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as [Zone, Record[] | null]
	}

	// ZonePurgeHistory removes historic records from the database, those marked "deleted".
	async ZonePurgeHistory(zone: string): Promise<[Zone, Record[] | null]> {
		const fn: string = "ZonePurgeHistory"
		const paramTypes: string[][] = [["string"]]
		const returnTypes: string[][] = [["Zone"],["[]","Record"]]
		const params: any[] = [zone]
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as [Zone, Record[] | null]
	}

	// ZoneAdd adds a new zone to the database. A TSIG credential is created
	// automatically. Records are fetched returning the new zone, in the background.
	// 
	// If pc.ProviderName is non-empty, a new ProviderConfig is added.
	async ZoneAdd(z: Zone, notifies: ZoneNotify[] | null): Promise<Zone> {
		const fn: string = "ZoneAdd"
		const paramTypes: string[][] = [["Zone"],["[]","ZoneNotify"]]
		const returnTypes: string[][] = [["Zone"]]
		const params: any[] = [z, notifies]
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as Zone
	}

	// ZoneDelete removes a zone and all its records, credentials and dns notify addresses, from the database.
	async ZoneDelete(zone: string): Promise<void> {
		const fn: string = "ZoneDelete"
		const paramTypes: string[][] = [["string"]]
		const returnTypes: string[][] = []
		const params: any[] = [zone]
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as void
	}

	// ZoneUpdate updates the provider config and refresh & sync interval for a zone.
	async ZoneUpdate(z: Zone): Promise<Zone> {
		const fn: string = "ZoneUpdate"
		const paramTypes: string[][] = [["Zone"]]
		const returnTypes: string[][] = [["Zone"]]
		const params: any[] = [z]
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as Zone
	}

	// ZoneNotify send a DNS notify message to an address.
	async ZoneNotify(zoneNotifyID: number): Promise<void> {
		const fn: string = "ZoneNotify"
		const paramTypes: string[][] = [["int64"]]
		const returnTypes: string[][] = []
		const params: any[] = [zoneNotifyID]
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as void
	}

	// ZoneNotifyAdd adds a new DNS NOTIFY destination to a zone.
	async ZoneNotifyAdd(zn: ZoneNotify): Promise<ZoneNotify> {
		const fn: string = "ZoneNotifyAdd"
		const paramTypes: string[][] = [["ZoneNotify"]]
		const returnTypes: string[][] = [["ZoneNotify"]]
		const params: any[] = [zn]
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as ZoneNotify
	}

	// ZoneNotifyDelete removes a DNS NOTIFY destination from a zone.
	async ZoneNotifyDelete(zoneNotifyID: number): Promise<void> {
		const fn: string = "ZoneNotifyDelete"
		const paramTypes: string[][] = [["int64"]]
		const returnTypes: string[][] = []
		const params: any[] = [zoneNotifyID]
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as void
	}

	// ZoneCredentialAdd adds a new TSIG or TLS public key credential to a zone.
	async ZoneCredentialAdd(zone: string, c: Credential): Promise<Credential> {
		const fn: string = "ZoneCredentialAdd"
		const paramTypes: string[][] = [["string"],["Credential"]]
		const returnTypes: string[][] = [["Credential"]]
		const params: any[] = [zone, c]
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as Credential
	}

	// ZoneCredentialDelete removes a TSIG/TLS public key credential from a zone.
	async ZoneCredentialDelete(credentialID: number): Promise<void> {
		const fn: string = "ZoneCredentialDelete"
		const paramTypes: string[][] = [["int64"]]
		const returnTypes: string[][] = []
		const params: any[] = [credentialID]
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as void
	}

	// ZoneImportRecords parses records in zonefile, assuming standard zone file syntax,
	// and adds the records via the provider and syncs the newly added records to the
	// local database. The latest records, included historic/deleted records after the
	// sync are returned.
	async ZoneImportRecords(zone: string, zonefile: string): Promise<Record[] | null> {
		const fn: string = "ZoneImportRecords"
		const paramTypes: string[][] = [["string"],["string"]]
		const returnTypes: string[][] = [["[]","Record"]]
		const params: any[] = [zone, zonefile]
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as Record[] | null
	}

	// RecordAdd adds a single record through the provider, then waits for it to
	// synchronize back to the local database. The newly added database record is
	// returned.
	async RecordAdd(zone: string, nr: RecordNew): Promise<Record> {
		const fn: string = "RecordAdd"
		const paramTypes: string[][] = [["string"],["RecordNew"]]
		const returnTypes: string[][] = [["Record"]]
		const params: any[] = [zone, nr]
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as Record
	}

	// RecordUpdate updates and existing record, replacing it with the new version. The
	// name and type must be the same. Only the TTL and value can be changed for an
	// existing record. The updated or new local database record is returned after a sync.
	async RecordUpdate(zone: string, recordID: number, rn: RecordNew): Promise<Record> {
		const fn: string = "RecordUpdate"
		const paramTypes: string[][] = [["string"],["int64"],["RecordNew"]]
		const returnTypes: string[][] = [["Record"]]
		const params: any[] = [zone, recordID, rn]
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as Record
	}

	// RecordDelete removes a record through the provider and waits for the change to
	// be synced to the local database. The historic/deleted record is returned.
	async RecordDelete(zone: string, recordID: number): Promise<Record> {
		const fn: string = "RecordDelete"
		const paramTypes: string[][] = [["string"],["int64"]]
		const returnTypes: string[][] = [["Record"]]
		const params: any[] = [zone, recordID]
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as Record
	}

	// Version returns the version of this build of the application.
	async Version(): Promise<string> {
		const fn: string = "Version"
		const paramTypes: string[][] = []
		const returnTypes: string[][] = [["string"]]
		const params: any[] = []
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as string
	}

	// DNSTypeNames returns a mapping of DNS type numbers to strings.
	async DNSTypeNames(): Promise<{ [key: string]: string }> {
		const fn: string = "DNSTypeNames"
		const paramTypes: string[][] = []
		const returnTypes: string[][] = [["{}","string"]]
		const params: any[] = []
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as { [key: string]: string }
	}

	// KnownProviders is a dummy method whose sole purpose is to get an API description
	// of all known providers in the API documentation, for use in TypeScript.
	async KnownProviders(): Promise<[KnownProviders, sherpadocSection]> {
		const fn: string = "KnownProviders"
		const paramTypes: string[][] = []
		const returnTypes: string[][] = [["KnownProviders"],["sherpadocSection"]]
		const params: any[] = []
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as [KnownProviders, sherpadocSection]
	}

	// Docs returns the API docs. The TypeScript code uses this documentation to build
	// a UI for the fields in configurations for providers (as included through
	// KnownProviders).
	async Docs(): Promise<sherpadocSection> {
		const fn: string = "Docs"
		const paramTypes: string[][] = []
		const returnTypes: string[][] = [["sherpadocSection"]]
		const params: any[] = []
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as sherpadocSection
	}

	// ProviderConfigTest tests the provider configuration for zone. Used before
	// creating a zone with a new config or updating the config for an existing zone.
	async ProviderConfigTest(zone: string, provider: string, providerConfigJSON: string): Promise<number> {
		const fn: string = "ProviderConfigTest"
		const paramTypes: string[][] = [["string"],["string"],["string"]]
		const returnTypes: string[][] = [["int32"]]
		const params: any[] = [zone, provider, providerConfigJSON]
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as number
	}

	// ProviderConfigs returns all provider configs.
	async ProviderConfigs(): Promise<ProviderConfig[] | null> {
		const fn: string = "ProviderConfigs"
		const paramTypes: string[][] = []
		const returnTypes: string[][] = [["[]","ProviderConfig"]]
		const params: any[] = []
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as ProviderConfig[] | null
	}

	// ProviderConfigAdd adds a new provider config.
	async ProviderConfigAdd(pc: ProviderConfig): Promise<ProviderConfig> {
		const fn: string = "ProviderConfigAdd"
		const paramTypes: string[][] = [["ProviderConfig"]]
		const returnTypes: string[][] = [["ProviderConfig"]]
		const params: any[] = [pc]
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as ProviderConfig
	}

	// ProviderConfigUpdate updates a provider config.
	async ProviderConfigUpdate(pc: ProviderConfig): Promise<ProviderConfig> {
		const fn: string = "ProviderConfigUpdate"
		const paramTypes: string[][] = [["ProviderConfig"]]
		const returnTypes: string[][] = [["ProviderConfig"]]
		const params: any[] = [pc]
		return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params) as ProviderConfig
	}
}

export const defaultBaseURL = (function() {
	let p = location.pathname
	if (p && p[p.length - 1] !== '/') {
		let l = location.pathname.split('/')
		l = l.slice(0, l.length - 1)
		p = '/' + l.join('/') + '/'
	}
	return location.protocol + '//' + location.host + p + 'api/'
})()

// NOTE: code below is shared between github.com/mjl-/sherpaweb and github.com/mjl-/sherpats.
// KEEP IN SYNC.

export const supportedSherpaVersion = 1

export interface Section {
	Name: string
	Docs: string
	Functions: Function[]
	Sections: Section[]
	Structs: Struct[]
	Ints: Ints[]
	Strings: Strings[]
	Version: string // only for top-level section
	SherpaVersion: number // only for top-level section
	SherpadocVersion: number // only for top-level section
}

export interface Function {
	Name: string
	Docs: string
	Params: Arg[]
	Returns: Arg[]
}

export interface Arg {
	Name: string
	Typewords: string[]
}

export interface Struct {
	Name: string
	Docs: string
	Fields: Field[]
}

export interface Field {
	Name: string
	Docs: string
	Typewords: string[]
}

export interface Ints {
	Name: string
	Docs: string
	Values: {
		Name: string
		Value: number
		Docs: string
	}[] | null
}

export interface Strings {
	Name: string
	Docs: string
	Values: {
		Name: string
		Value: string
		Docs: string
	}[] | null
}

export type NamedType = Struct | Strings | Ints
export type TypenameMap = { [k: string]: NamedType }

// verifyArg typechecks "v" against "typewords", returning a new (possibly modified) value for JSON-encoding.
// toJS indicate if the data is coming into JS. If so, timestamps are turned into JS Dates. Otherwise, JS Dates are turned into strings.
// allowUnknownKeys configures whether unknown keys in structs are allowed.
// types are the named types of the API.
export const verifyArg = (path: string, v: any, typewords: string[], toJS: boolean, allowUnknownKeys: boolean, types: TypenameMap, opts: ClientOptions): any => {
	return new verifier(types, toJS, allowUnknownKeys, opts).verify(path, v, typewords)
}

export const parse = (name: string, v: any): any => verifyArg(name, v, [name], true, false, types, defaultOptions)

class verifier {
	constructor(private types: TypenameMap, private toJS: boolean, private allowUnknownKeys: boolean, private opts: ClientOptions) {
	}

	verify(path: string, v: any, typewords: string[]): any {
		typewords = typewords.slice(0)
		const ww = typewords.shift()

		const error = (msg: string) => {
			if (path != '') {
				msg = path + ': ' + msg
			}
			throw new Error(msg)
		}

		if (typeof ww !== 'string') {
			error('bad typewords')
			return // should not be necessary, typescript doesn't see error always throws an exception?
		}
		const w: string = ww

		const ensure = (ok: boolean, expect: string): any => {
			if (!ok) {
				error('got ' + JSON.stringify(v) + ', expected ' + expect)
			}
			return v
		}

		switch (w) {
		case 'nullable':
			if (v === null || v === undefined && this.opts.nullableOptional) {
				return v
			}
			return this.verify(path, v, typewords)
		case '[]':
			if (v === null && this.opts.slicesNullable || v === undefined && this.opts.slicesNullable && this.opts.nullableOptional) {
				return v
			}
			ensure(Array.isArray(v), "array")
			return v.map((e: any, i: number) => this.verify(path + '[' + i + ']', e, typewords))
		case '{}':
			if (v === null && this.opts.mapsNullable || v === undefined && this.opts.mapsNullable && this.opts.nullableOptional) {
				return v
			}
			ensure(v !== null || typeof v === 'object', "object")
			const r: any = {}
			for (const k in v) {
				r[k] = this.verify(path + '.' + k, v[k], typewords)
			}
			return r
		}

		ensure(typewords.length == 0, "empty typewords")
		const t = typeof v
		switch (w) {
		case 'any':
			return v
		case 'bool':
			ensure(t === 'boolean', 'bool')
			return v
		case 'int8':
		case 'uint8':
		case 'int16':
		case 'uint16':
		case 'int32':
		case 'uint32':
		case 'int64':
		case 'uint64':
			ensure(t === 'number' && Number.isInteger(v), 'integer')
			return v
		case 'float32':
		case 'float64':
			ensure(t === 'number', 'float')
			return v
		case 'int64s':
		case 'uint64s':
			ensure(t === 'number' && Number.isInteger(v) || t === 'string', 'integer fitting in float without precision loss, or string')
			return '' + v
		case 'string':
			ensure(t === 'string', 'string')
			return v
		case 'timestamp':
			if (this.toJS) {
				ensure(t === 'string', 'string, with timestamp')
				const d = new Date(v)
				if (d instanceof Date && !isNaN(d.getTime())) {
					return d
				}
				error('invalid date ' + v)
			} else {
				ensure(t === 'object' && v !== null, 'non-null object')
				ensure(v.__proto__ === Date.prototype, 'Date')
				return v.toISOString()
			}
		}

		// We're left with named types.
		const nt = this.types[w]
		if (!nt) {
			error('unknown type ' + w)
		}
		if (v === null) {
			error('bad value ' + v + ' for named type ' + w)
		}

		if (structTypes[nt.Name]) {
			const t = nt as Struct
			if (typeof v !== 'object') {
				error('bad value ' + v + ' for struct ' + w)
			}

			const r: any = {}
			for (const f of t.Fields) {
				r[f.Name] = this.verify(path + '.' + f.Name, v[f.Name], f.Typewords)
			}
			// If going to JSON also verify no unknown fields are present.
			if (!this.allowUnknownKeys) {
				const known: { [key: string]: boolean } = {}
				for (const f of t.Fields) {
					known[f.Name] = true
				}
				Object.keys(v).forEach((k) => {
					if (!known[k]) {
						error('unknown key ' + k + ' for struct ' + w)
					}
				})
			}
			return r
		} else if (stringsTypes[nt.Name]) {
			const t = nt as Strings
			if (typeof v !== 'string') {
				error('mistyped value ' + v + ' for named strings ' + t.Name)
			}
			if (!t.Values || t.Values.length === 0) {
				return v
			}
			for (const sv of t.Values) {
				if (sv.Value === v) {
					return v
				}
			}
			error('unknown value ' + v + ' for named strings ' + t.Name)
		} else if (intsTypes[nt.Name]) {
			const t = nt as Ints
			if (typeof v !== 'number' || !Number.isInteger(v)) {
				error('mistyped value ' + v + ' for named ints ' + t.Name)
			}
			if (!t.Values || t.Values.length === 0) {
				return v
			}
			for (const sv of t.Values) {
				if (sv.Value === v) {
					return v
				}
			}
			error('unknown value ' + v + ' for named ints ' + t.Name)
		} else {
			throw new Error('unexpected named type ' + nt)
		}
	}
}


export interface ClientOptions {
	baseURL?: string
	aborter?: {abort?: () => void}
	timeoutMsec?: number
	skipParamCheck?: boolean
	skipReturnCheck?: boolean
	slicesNullable?: boolean
	mapsNullable?: boolean
	nullableOptional?: boolean
	csrfHeader?: string
	login?: (reason: string) => Promise<string>
}

export interface AuthState {
	token?: string // For csrf request header.
	loginPromise?: Promise<void> // To let multiple API calls wait for a single login attempt, not each opening a login popup.
}

const _sherpaCall = async (baseURL: string, authState: AuthState, options: ClientOptions, paramTypes: string[][], returnTypes: string[][], name: string, params: any[]): Promise<any> => {
	if (!options.skipParamCheck) {
		if (params.length !== paramTypes.length) {
			return Promise.reject({ message: 'wrong number of parameters in sherpa call, saw ' + params.length + ' != expected ' + paramTypes.length })
		}
		params = params.map((v: any, index: number) => verifyArg('params[' + index + ']', v, paramTypes[index], false, false, types, options))
	}
	const simulate = async (json: string) => {
		const config = JSON.parse(json || 'null') || {}
		const waitMinMsec = config.waitMinMsec || 0
		const waitMaxMsec = config.waitMaxMsec || 0
		const wait = Math.random() * (waitMaxMsec - waitMinMsec)
		const failRate = config.failRate || 0
		return new Promise<void>((resolve, reject) => {
			if (options.aborter) {
				options.aborter.abort = () => {
					reject({ message: 'call to ' + name + ' aborted by user', code: 'sherpa:aborted' })
					reject = resolve = () => { }
				}
			}
			setTimeout(() => {
				const r = Math.random()
				if (r < failRate) {
					reject({ message: 'injected failure on ' + name, code: 'server:injected' })
				} else {
					resolve()
				}
				reject = resolve = () => { }
			}, waitMinMsec + wait)
		})
	}
	// Only simulate when there is a debug string. Otherwise it would always interfere
	// with setting options.aborter.
	let json: string = ''
	try {
		json = window.localStorage.getItem('sherpats-debug') || ''
	} catch (err) {}
	if (json) {
		await simulate(json)
	}

	const fn = (resolve: (v: any) => void, reject: (v: any) => void) => {
		let resolve1 = (v: any) => {
			resolve(v)
			resolve1 = () => { }
			reject1 = () => { }
		}
		let reject1 = (v: { code: string, message: string }) => {
			if ((v.code === 'user:noAuth' || v.code === 'user:badAuth')  && options.login) {
				const login = options.login
				if (!authState.loginPromise) {
					authState.loginPromise = new Promise((aresolve, areject) => {
						login(v.code === 'user:badAuth' ? (v.message || '') : '')
						.then((token) => {
							authState.token = token
							authState.loginPromise = undefined
							aresolve()
						}, (err: any) => {
							authState.loginPromise = undefined
							areject(err)
						})
					})
				}
				authState.loginPromise
				.then(() => {
					fn(resolve, reject)
				}, (err: any) => {
					reject(err)
				})
				return
			}
			reject(v)
			resolve1 = () => { }
			reject1 = () => { }
		}

		const url = baseURL + name
		const req = new window.XMLHttpRequest()
		if (options.aborter) {
			options.aborter.abort = () => {
				req.abort()
				reject1({ code: 'sherpa:aborted', message: 'request aborted' })
			}
		}
		req.open('POST', url, true)
		if (options.csrfHeader && authState.token) {
			req.setRequestHeader(options.csrfHeader, authState.token)
		}
		if (options.timeoutMsec) {
			req.timeout = options.timeoutMsec
		}
		req.onload = () => {
			if (req.status !== 200) {
				if (req.status === 404) {
					reject1({ code: 'sherpa:badFunction', message: 'function does not exist' })
				} else {
					reject1({ code: 'sherpa:http', message: 'error calling function, HTTP status: ' + req.status })
				}
				return
			}

			let resp: any
			try {
				resp = JSON.parse(req.responseText)
			} catch (err) {
				reject1({ code: 'sherpa:badResponse', message: 'bad JSON from server' })
				return
			}
			if (resp && resp.error) {
				const err = resp.error
				reject1({ code: err.code, message: err.message })
				return
			} else if (!resp || !resp.hasOwnProperty('result')) {
				reject1({ code: 'sherpa:badResponse', message: "invalid sherpa response object, missing 'result'" })
				return
			}

			if (options.skipReturnCheck) {
				resolve1(resp.result)
				return
			}
			let result = resp.result
			try {
				if (returnTypes.length === 0) {
					if (result) {
						throw new Error('function ' + name + ' returned a value while prototype says it returns "void"')
					}
				} else if (returnTypes.length === 1) {
					result = verifyArg('result', result, returnTypes[0], true, true, types, options)
				} else {
					if (result.length != returnTypes.length) {
						throw new Error('wrong number of values returned by ' + name + ', saw ' + result.length + ' != expected ' + returnTypes.length)
					}
					result = result.map((v: any, index: number) => verifyArg('result[' + index + ']', v, returnTypes[index], true, true, types, options))
				}
			} catch (err) {
				let errmsg = 'bad types'
				if (err instanceof Error) {
					errmsg = err.message
				}
				reject1({ code: 'sherpa:badTypes', message: errmsg })
			}
			resolve1(result)
		}
		req.onerror = () => {
			reject1({ code: 'sherpa:connection', message: 'connection failed' })
		}
		req.ontimeout = () => {
			reject1({ code: 'sherpa:timeout', message: 'request timeout' })
		}
		req.setRequestHeader('Content-Type', 'application/json')
		try {
			req.send(JSON.stringify({ params: params }))
		} catch (err) {
			reject1({ code: 'sherpa:badData', message: 'cannot marshal to JSON' })
		}
	}
	return await new Promise(fn)
}

}
